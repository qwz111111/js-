# 适配器模式

适配器模式：将一个类(对象)的接口(方法、属性)转化为用户需要的另一个接口。解决类(对象)之间接口不兼容的问题。

适配器模式的优缺点：

优点：
已有的功能如果只是接口不兼容，使用适配器适配已有功能，可以使原有逻辑得到更好的复用，有助于避免大规模改写现有代码；
可扩展性良好，在实现适配器功能的时候，可以调用自己开发的功能，从而方便地扩展系统的功能；
灵活性好，因为适配器并没有对原有对象的功能有所影响，如果不想使用适配器了，那么直接删掉即可，不会对使用原有对象的代码有影响；
缺点：会让系统变得零乱，明明调用 A，却被适配到了 B，如果系统中这样的情况很多，那么对可阅读性不太友好。如果没必要使用适配器模式的话，可以考虑重构，如果使用的话，可以考虑尽量把文档完善。
适配器模式的适用场景：

当你想用已有对象的功能，却想修改它的接口时，一般可以考虑一下是不是可以应用适配器模式。
如果你想要使用一个已经存在的对象，但是它的接口不满足需求，那么可以使用适配器模式，把已有的实现转换成你需要的接口；
如果你想创建一个可以复用的对象，而且确定需要和一些不兼容的对象一起工作，这种情况可以使用适配器模式，然后需要什么就适配什么；
适配器模式、代理模式以及装饰模式的区别：

适配器模式： 原功能不变，只转换了原有接口访问格式；提供一个不一样的接口，由于原来的接口格式不能用了，提供新的接口以满足新场景下的需求；
代理模式：原功能不变，但一般是经过限制访问的；提供一模一样的接口，由于不能直接访问目标对象，找个代理来帮忙访问，使用者可以就像访问目标对象一样来访问代理对象；
装饰模式：扩展功能，原有功能不变且可直接使用；

```// 原来的树形结构
const oldTreeData = [
  {
    name: '总部',
    place: '一楼',
    children: [
      {
        name: '财务部',
        place: '二楼'
      },
      {
        name: '生产部',
        place: '三楼'
      },
      {
        name: '开发部',
        place: '三楼',
        children: [
          {
            name: '软件部',
            place: '四楼',
            children: [
              { name: '后端部', place: '五楼' },
              { name: '前端部', place: '七楼' },
              { name: '技术部', place: '六楼' }
            ]
          },
          {
            name: '硬件部',
            place: '四楼',
            children: [
              { name: 'DSP部', place: '八楼' },
              { name: 'ARM部', place: '二楼' },
              { name: '调试部', place: '三楼' }
            ]
          }
        ]
      }
    ]
  }
]

// 树形结构平铺
function treeDataAdapter(treeData, lastArrayData = []) {
  treeData.forEach(item => {
    if (item.children) {
      treeDataAdapter(item.children, lastArrayData)
    }
    const { name, place } = item
    lastArrayData.push({ name, place })
  })
  return lastArrayData
}
// 返回平铺的组织结构
var data = treeDataAdapter(oldTreeData)

```
