# 外观模式
外观模式为一组复杂的子系统接口提供一个更高级的统一接口，通过这个接口使得对子系统接口的访问更容易。

外观模式的用途：将一些复杂操作封装起来，并创建一个简单的接口用于调用。

外观模式的适用场景：

维护设计粗糙和难以理解的遗留系统，或者系统非常复杂的时候，可以为这些系统设置外观模块，给外界提供清晰的接口，以后新系统只需与外观交互即可；
你写了若干小模块，可以完成某个大功能，但日后常用的是大功能，可以使用外观来提供大功能，因为外界也不需要了解小模块的功能；
团队协作时，可以给各自负责的模块建立合适的外观，以简化使用，节约沟通时间；
如果构建多层系统，可以使用外观模式来将系统分层，让外观模块成为每层的入口，简化层间调用，松散层间耦合；
外观模式的优缺点：

优点：
访问者不需要再了解子系统内部模块的功能，而只需和外观交互即可，使得访问者对子系统的 使用变得简单 ，符合最少知识原则，增强了可移植性和可读性；
减少了与子系统模块的直接引用，实现了访问者与子系统中模块之间的松耦合，增加了可维护性和可扩展性；
通过合理使用外观模式，可以帮助我们更好地划分系统访问层次，比如把需要暴露给外部的功能集中到外观中，这样既方便访问者使用，也很好地隐藏了内部的细节，提升了安全性；
缺点：
不符合开闭原则，对修改关闭，对扩展开放，如果外观模块出错，那么只能通过修改的方式来解决问题，因为外观模块是子系统的唯一出口；
不需要或不合理的使用外观会让人迷惑，过犹不及；
外观模式与中介者模式的区别：

外观模式：封装子使用者对子系统内模块的直接交互，方便使用者对子系统的调用；
中介者模式：封装子系统间各模块之间的直接交互，松散模块间的耦合；
```
function setBox(){
	var getId = document.getElementById('isShow');
	return {
		show : function(){
			getId.style.display = 'block';
		},
		hide : function(){
			getId.style.display = 'none';
		}
	}
}
```